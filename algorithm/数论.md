# 扩展欧几里得（exgcd)

## 问题：

$$
ax+by= c~~or ~~ax \equiv c(mod~b)\\
$$

## 推式子：

$$
ax+by=gcd(a, b)\\
bx+(a\%b)y = gcd(b, a\%b) = gcd(a, b) = ax+by\\
bx+(a-b\lfloor\frac ab\rfloor)y\\
bx+ay-b\lfloor\frac ab\rfloor y\\
ax+by=ay+b(x-\lfloor\frac ab\rfloor y)
$$

左边是上一个$x,y$状态的状态，做一次$gcd(a,b)=gcd(b, a\%b)$后，后一个$x，y$的状态就是y和$(\lfloor\frac ab\rfloor y)$ 

我们可以知道最后一个解是$x=1，y=0$此时$b=0,a=gcd$.

可以由最后一个解向上递推得到一开始的解。

# *线性同余方程

$ax+by=c$ 

$x_0,y_0$是一个特解，则$x=(kx_0\%\frac bd+\frac bd) \%\frac bd$ 是最小值。

## 题目

### [P1516 青蛙的约会](https://www.luogu.com.cn/problem/P1516)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll exgcd(ll &x, ll &y, ll a, ll b) {
    if(!b) {
        x = 1,  y = 0;
        return a;
    }
    ll d = exgcd(x, y, b, a%b);
    ll tmp = y;
    y = (x-a/b*y);
    x = tmp;
    return d;
}
int main() {
#ifndef ONLINE_JUDGE 
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif
    ll x, y, n, m, l, a, b;
    cin >> x >> y >> m >> n >> l;
    ll u = ((n-m+l)%l + l) % l, v = ((x-y+l)%l + l) % l;//注意取模。
    ll d = exgcd(a, b, u, l) ; 
    if(v % d) puts("Impossible");
    else {
        ll s = l/d, k = v/d;
        cout << (((k%s)*(a%s)%s+s) % s) << endl;
    }
    return 0;
}
```









### [LCM Walk](http://acm.hdu.edu.cn/showproblem.php?pid=5584)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e3+10;
const int inf = 0x7ffffff;
// #define int long long
int main() {
#ifndef ONLINE_JUDGE 
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif  
    int t, flag = 1;
    cin >> t;
    while(t--) {
        int n, m, ans = 1;
        cin >> n >> m;
        int d = __gcd(n, m);
        while(n && 1) {
            if(n < m) swap(n, m);
            if((1ll*n*d) % (m + d)) break;
            n = (1ll*n*d) / (m + d);
            if(__gcd(n, m) != d) break;
            ans++;
        }
        printf("Case #%d: %d\n", flag, ans);
        flag++;
    }
    return 0;
}
```









### [One Person Game](https://vjudge.z180.cn/problem/ZOJ-3593)

这样用拓展欧几里得就能解出x和y，剩下的就是找最优解的问题了，在这之前，我们先求出通解为

$x=x0+k*b/gcd(a,b)\\
y=y0+k*a/gcd(a,b)$
需要分类讨论一下：

若$x$和$y$同号，那么答案就是$max(x,y)$，因为我们可以将$min(x,y)$步都转化为每次走$a+b$步，剩下的单独走a步或单独走b步
若$x$和$y$异号，那么答案就是$abs(x)+abs(y)$，答案就是先向一个方向走$a$步或$b$步，然后再向另一个方向走另一种步数
我们现在假设当$x==y$时，有$x0+k*b/gcd(a,b)=y0+k*a/gcd(a,b)$，化简一下得到$k=(y0-x0)/(a/gcd(a,b)+b/gcd(a,b))$，因为x和y不一定真的相等，所以我们在$[k-1,k+1]$的闭区间中更新一下答案防止误差，最后输出答案即可
————————————————



```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6+10;
typedef long long ll;
ll exgcd(ll a, ll b, ll &x, ll &y) {
	if(b == 0) {
		x = 1, y = 0;
		return a;
	}
	ll d = exgcd(b, a%b, x, y);
	ll tmp = y;
	y = x-a/b*y;
	x = tmp; 
	return d;
}
int main() {
#ifndef ONLINE_JUDGE
	freopen("in.txt", "r", stdin);
	freopen("out.txt", "w", stdout);
#endif
	int t;
	scanf("%d", &t);
	while(t--) {
		ll A, B, a, b;
		scanf("%lld%lld%lld%lld", &A, &B, &a, &b);
		ll h = labs(A-B), d = __gcd(a, b);
		if(h % d) puts("-1");
		else {
			ll x, y;
			exgcd(a, b, x, y);
			ll u = b/d, v = a/d;
			x = h/d * x, y = h/d * y;
			ll k = (y-x)/(u+v), ans = (1ll<<32);
			for(int i=k-1; i<=k+1; i++) {
				ll tmpx = x + i*u;
				ll tmpy = y - i*v;
				ll tmp = (tmpx*tmpy >= 0) ? max(labs(tmpx), labs(tmpy)) : labs(tmpx)+labs(tmpy);
				ans = min(ans, tmp);
			}
			printf("%lld\n", ans);
		}
	}
	return 0;
}
```























# 中国剩余定理CRT 

一元线性同余方程组



## 问题：

给出t个式子，求x的最小值。

其中$n_i$两两互质。
$$
x\equiv~a_i(mod~n_i)\\
$$

## 计算过程：

$$
n=\prod_{i=1}^tn_i\\
m_i=\frac n{n_i}\\
m_im_i^{-1}\equiv1(mod~n_i)\\
x = \sum_{i=1}^t(a_im_im_i^{-1})~mod~n\\
$$



## 简单证明：

$$
x=\sum_{i=1}^t(a_im_im_i^{-1})~mod~n\\
(x~mod~n)~mod~n_i=x~mod~n_i\\
for~\forall j~let~x~mod~n_j\\
\sum_{i=1}^t(a_im_im_i^{-1})~mod~n_j~mod~n\\
if ~i\neq j\\
a_im_im_i^{-1}~mod~n_j=0\\
else~i=j\\
m_im_i^{-1}~mod~n_i=1\\
a_im_im_i^{-1}~mod~n_i=a_i\\
$$



## 细节：

在做乘法的时候可能会爆longlong，所以得用龟速乘或者直接搞大数。

求$m_i$在$n_i$下的逆元要先求出$n_i$的欧拉函数值（线性筛）





## 题目

### P1495 【模板】中国剩余定理(CRT)/曹冲养猪



使用龟速乘，防止爆longlong

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6+10;
int p[N], phi[N], tot;
bool st[N];
ll mul(ll x, ll y, ll mod) {
    ll ans = 0;
    while(y) {
        if(y & 1) ans = (ans + x) % mod;
        x = (x + x) % mod;
        y >>= 1;
    }
    return ans%mod;
}
ll qpow(ll x, ll y, ll mod) {
    ll ans = 1;
    while(y) {
        if(y & 1) ans = mul(ans, x, mod);
        x = mul(x, x, mod);
        y >>= 1;
    }
    return ans%mod;
}
void init() {
    phi[1] = 1;
    for(int i=2; i<N; i++) {
        if(!st[i]) p[tot++] = i, phi[i] = i-1;
        for(int j=0; j<tot&&i*p[j]<N; j++) {
            st[i*p[j]] = 1;
            if(i % p[j] == 0) {
                phi[i*p[j]] = p[j] * phi[i];
                break;
            }
            phi[i*p[j]] = (p[j]-1)*phi[i];
        }
    }
}
ll n[20], m[20];
int main() {
#ifndef ONLINE_JUDGE 
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif
    init();
    ll t, n1 = 1ll, m1, inv;
    cin >> t;
    for(int i=1; i<=t; i++) {
        cin >> n[i] >> m[i];
        n1 = n1 * n[i];
    } 
    ll ans = 0ll;
    for(int i=1; i<=t; i++) {
        m1 = n1 / n[i];
        inv = qpow(m1, 1ll*phi[n[i]]-1, n1);
        ans = (ans + mul(m[i], mul(m1, inv, n1), n1)) % n1;
    }
    cout << (ans%n1 + n1) % n1;
    return 0;
}
```



### [P2480 [SDOI2010]古代猪文(CRT+Lucas)](https://www.luogu.com.cn/problem/P2480)

问题：
$$
g^{\sum_{k|n}C_n^k}~\%~mod\\
$$
解题思路：

用扩展欧拉定理转化成求解指数是多少，$\sum_{k|n}C_n^k~\%~\phi(mod)$

$\phi(mod)$不是素数，但$\phi(mod)$是由多个一次素数组成，且素数较小，我么就用中国剩余定理来分解一下$\phi(mod)$，求$C_n^k$在各个质数下的模数是多少。

但$C_n^k~\%~p$中$n，k$较大，但$p$较小，所以我们就用$Lucas$定理来求解。

， 

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 999911659;
const int Mod = mod-1;
const int N = 36000;
ll p[5] = {1, 2, 3, 4679, 35617};
ll f[N], a[20], ans;
void init(ll pp) {
    f[0] = 1;
    for(int i=1; i<=pp; i++) {
        f[i] = 1ll*i*f[i-1]%pp;
    }
}

ll qpow(ll x, ll y, ll pp) {
    ll ans = 1;
    x %= pp;
    while(y) {
        if(y & 1) ans = ans * x % pp;
        x = x * x % pp;
        y >>= 1;
    }
    return ans % pp;
}

ll C(ll n, ll m, ll pp) {
    if(n < m) return 0ll;//细节
    ll inv1 = qpow(f[m], pp-2, pp);
    ll inv2 = qpow(f[n-m], pp-2, pp);
    return 1ll*f[n]*inv1%pp*inv2%pp;
}

ll lucas(ll n, ll m, ll pp) {
    if(n < m) return 0ll;//细节
    if(!n) return 1ll;
    return C(n%pp, m%pp, pp)*lucas(n/pp, m/pp, pp) % pp;
}

void CRT() {
    for(int i=1; i<5; i++) {
        ll m = Mod/p[i];
        ll inv = qpow(m, p[i]-2, p[i]);
        ans = (ans + a[i]*m%Mod*inv%Mod)%Mod;
    }
}
int main() {
#ifndef ONLINE_JUDGE 
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif  
    ll n, g;
    cin >>n >> g;
    if(g % mod == 0) {
        cout << 0 << endl;
        return 0;
    }
    for(int i=1; i<5; i++) {
        init(p[i]);
        for(int j=1; 1ll*j*j<=n; j++) {
            if(n % j == 0) {
                a[i] = (a[i] + lucas(n, j, p[i])) % p[i];
                if(1ll*j*j != n) {
                    a[i] = (a[i] + lucas(n, n/j, p[i])) % p[i];
                }
            }
        }
    }
    CRT();
    cout << qpow(g, ans, mod)%mod << endl;
    return 0;
}
```



## 不互质的中国剩余定理

$$
x\equiv b_i(mod~a_i)
$$

推导
$$
\begin{aligned}
&x\equiv b_1(mod~a_1)\\
&x\equiv b_2(mod~a_2)\\
&\\
&b_1+x_1a_1=b_2+x_2a_2\\
&(b_2-b_1)=x_1a_1(mod~a_2)\\
&\\
&d =(a_1,a_2)\space,c=b_1-b_2\\
&\frac cd\equiv\frac {x_1a_1}d(mod~\frac {a_2}d)\\
&x_1\equiv\frac cd(\frac {a_1}d)^{-1}(mod~\frac{a_2}d)\\
&X=\frac cd(\frac {a_1}d)^{-1}(mod~\frac {a_2}d)\\
&x_1=\frac {a_2}dy+X\\
&x=x_1a_1+b_1\\
&x=\frac{a_2a_1}dy+a_1X+b_1\\
&x=a_1X+b_1(mod~\frac{a_1a_2}d)
\end{aligned}
$$




## Garner 算法（CRT扩展）

  ## 思想：

当一个数很大的时候，用一组互质的数来表示它，这样一来，我们就能用$lucas$定理来求解。

$a$满足线性方程组，且$a<\prod_{i=1}^np_i$其中($p_i$为质数)
$$
\begin{cases} a&\equiv~a_1~(mod~p_1)\\
a&\equiv~a_2~(mod~p_2)\\
&\vdots\\
a&\equiv~a_n~(mod~p_n)\\
\end{cases}
$$
我们可以用下面的式子（a的混合基数表示）表示a。
$$
a=x_1+x_2p_1+x_3p_1p_2...x_n\prod_{i=1}^{n-1}p_i
$$
证明&&解法：$(inv(x,y)表示x在模y下的逆元)$
$$
a~\equiv~a_1(mod~p_1)\equiv~x_1(mod~p_1)\\
\therefore x_1 = a_1\\
a~\equiv a_2(mod~p_2)\equiv~x_1+x_2p1(mod~p_2)\\
\therefore x_2=(a_2-x_1)\times inv(p_1,p_2)\\
a~\equiv a_3(mod~p_3)\equiv~x_1+x_2p1+x_3p_1p_2(mod~p_3)\\
\therefore x_3=((a_3-x_1)\times inv(p_1,p_3)-x2)\times inv(p_2,p_3)\\
...\\
x_n=((((a_n-x_1)\times inv(p_1,p_n)-x_2)\times inv(p_2,p_n)-x_3)\times...)\times inv(p_{n-1},p_n)
$$


## 题目：







# 二次剩余

## 定义

$p$是一个奇素数。
$$
x^2\equiv n(mod~p)
$$
判断n是否有解勒让德符号 $\equiv$ 欧拉判别准则。

勒让德符号
$$
\left(\frac {n}{p}\right)=\begin{cases}1& p\nmid n~\and~n是p的二次剩余\\
-1&p\nmid n~\and~n不是p的二次剩余\\
0&p\mid n
\end{cases}
$$
在区间$[1,p-1]$中存在解的数称为$p$的二次剩余，有$\frac {p-1}{2}$个。

已知$(p-k)^2\equiv k^2(mod~p)$，则当$k\in[1,\frac {(p-1)}2]$，等式成立，当$k\in(\frac {(p-1)}2,p-1]$，和前面的重复。

只要每个$k^2$都不同，就可以说明$p$的二次剩余有$\frac {(p-1)}2$个。

假设$x^2\equiv y^2(mod~p)$

。。。

欧拉判别式：
$$
\left(\frac {n}{p}\right)\equiv n^\frac{(p-1)}2(mod~p)
$$
简单理解：
$$
n^\frac {(p-1)}2\equiv(n^{(p-1)})^\frac 12(mod~p)\equiv \sqrt1\equiv\pm1(mod~p)
$$
 等于-1时无解，所以此时n不是p的二次剩余



## Cipolla 算法(求解算法)

### 理解类似复数域的东西。

$i=\sqrt{-1}$，而$n$可能在模$p$的情况下得不到整数解，所以我们也弄一个复数域。

就像是当$n$不是$p$的二次剩余的时候，我们设$w^2\equiv n$。



当n是p的二次剩余时，我们找到一个数$a$使$(a^2-n)$不是p的二次剩余。则$x^2\equiv n(mod~p)$的解是$(a-w)^\frac {(p+1)}2$

### 证明：

先证明一些小定理：

定理1：$(a+b)^p\equiv a^p+b^p$
$$
\begin{aligned}(a+b)^p&\equiv\sum_{i=0}^pC_p^ia^{p-i}b^i\\
&\equiv\sum_{i=0}^p\frac {p!}{i!(p-i!)}a^{p-i}b^i\\
&\equiv a^p+b^p(mod~p)
\end{aligned}
$$
​	定理2：$w^p\equiv-w(mod~p)$
$$
\begin{aligned}
w^p&\equiv w^{p-1}w\\
&\equiv(w^2)^{\frac {p-1}2}w\\
&\equiv(n)^\frac {p-1}2w\\
&\equiv-w\\
\end{aligned}
$$
证明：$x^2\equiv n(mod~p)$的解是$(a-w)^\frac {(p+1)}2$，设$w^2=(a^2-n)$
$$
\begin{aligned}
x&\equiv(a-w)^\frac {p+1}2\\
&\equiv((a-w)^{p+1})^\frac 12\\
&\equiv((a-w)^{p}(a-w))^\frac 12\\
&\equiv((a^p-w^p)(a-w))^\frac 12\\
&\equiv((a+w)(a-w))^\frac 12\\
&\equiv(a^2-w^2)^\frac 12\\
&\equiv(a^2-(a^2-n))^\frac 12\\
&\equiv n^\frac 12(mod~p)\\
\end{aligned}
$$
$\therefore x\equiv(a+w)^{\frac {(p+1)}2}\equiv(mod~p)$

## 模板题
[【模板】二次剩余](https://www.luogu.com.cn/problem/P5491)



```c
#include<bits/stdc++.h>

using namespace std;
mt19937_64 gen(time(0));
typedef long long ll;

ll n, mod, w;

ll qpow(ll x, ll y) {
    ll ans = 1;
    while(y) {
        if(y & 1) ans = ans * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return ans;
}

struct Y {
    ll x, y;
    Y operator * (const Y & a) {
        Y tmp;
        tmp.x = (x * a.x % mod + y * a.y % mod * w % mod) % mod;
        tmp.y = (x * a.y % mod + y * a.x % mod) % mod;
        return tmp; 
    }
    Y operator + (const Y & a) {
        Y tmp;
        tmp.x = (x + a.x) % mod;
        tmp.y = (y + a.y) % mod;
        return tmp;
    }
};

Y ksm(Y a, ll x) {
    Y ans = {1, 0};
    while(x) {
        if(x & 1) ans = ans * a;
        a = a * a;
        x >>= 1;
    }
    return ans;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif
    int t;
    scanf("%d", &t);
    while(t--) {
        scanf("%lld%lld", &n, &mod);
        n %= mod;
        if(n == 0) printf("0\n");
        else if(qpow(n, (mod-1)/2) == mod-1) puts("Hola!");
        else {
            ll tmp;
            while(1) {
                tmp = gen() % mod;
                w = (tmp * tmp % mod - n + mod) % mod;
                if(qpow(w, (mod-1)/2) == mod-1) break;
            }
            Y a = {tmp, 1};
            a = ksm(a, (mod+1)/2);
            tmp = mod - a.x;
            if(tmp == a.x) cout << a.x << endl;
            else cout << min(tmp, a.x) << ' ' << max(tmp, a.x) << endl;
        }
    }
    return 0;
}
```

# 类欧几里得

问题：$f,g,h$ 
$$
f(a, b, c, n) = \sum_{i=0}^n\lfloor \frac {ai+b}c\rfloor\\
\sum_{i=0}^n\lfloor \frac {(\lfloor\frac ac\rfloor c+a\%c)i+\lfloor\frac bc\rfloor c+b\%c\rfloor}c\rfloor\\
\frac {(n+1)n}2+(n+1)+\sum_{i=0}^n\lfloor \frac {(a\%c)i+(b\%c)}c\rfloor\\
\frac {(n+1)n}2+(n+1)+f(a\%c,b\%c,c,n)\\
let~a\%c=x,b\%c=y~~x,y<c;\\
f(x,y,c,n)\\
\sum_{i=0}^n\lfloor\frac {xi+y}c\rfloor\\
\sum_{i=0}^n\sum_{j=0}^{\lfloor\frac {xi+y}c\rfloor-1}1\\
\sum_{j=0}^{\lfloor\frac {xn+y}c\rfloor-1}\sum_{i=0}^n[j<\lfloor\frac {xi+y}c\rfloor]\\
\sum_{j=0}^{\lfloor\frac {xn+y}c\rfloor-1}\sum_{i=0}^n[j+1\le\lfloor\frac {xi+y}c\rfloor]\\
\sum_{j=0}^{\lfloor\frac {xn+y}c\rfloor-1}\sum_{i=0}^n[(j+1)c\le xi+y]\\
\sum_{j=0}^{\lfloor\frac {xn+y}c\rfloor-1}\sum_{i=0}^n[cj+c-y-1< xi]\\
\sum_{j=0}^{\lfloor\frac {xn+y}c\rfloor-1}\sum_{i=0}^n[\lfloor\frac{cj+c-y-1}x\rfloor< i]\\
\sum_{j=0}^{\lfloor\frac {xn+y}c\rfloor-1}\sum_{i=0}^n[\lfloor\frac{cj+c-y-1}x\rfloor< i]\\
\sum_{j=0}^{\lfloor\frac {xn+y}c\rfloor-1}n-\lfloor\frac{cj+c-y-1}x\rfloor\\
let~\frac{xn+y}c=m\\
nm-\sum_{i=0}^{m-1}f(c,c-y-1,a,m-1)\\
$$





$$
g(a,b,c,n)=\sum_{i=0}^n\lfloor\frac {ai+b}c\rfloor i\\
\sum_{i=0}^n\lfloor\frac {(\lfloor\frac ac\rfloor c+a~mod~c)i+\lfloor \frac bc\rfloor c}c\rfloor i\\ 
\sum_{i=0}^n\lfloor\frac ac\rfloor i^2+\lfloor\frac bc\rfloor i+\lfloor\frac{a~mod~c~i+b~mod~c}c\rfloor i\\
\lfloor\frac ac\rfloor\frac {n(n+1)(2n+1)}6+\lfloor\frac bc\rfloor\frac{n(n+1)}2+g(a~mod~c, b~mod~c,c,d)\\
$$





























# BSGS

## 基础篇

### 问题：

给出$a，b，p$，其中$gcd(a,p)=1$，求$x$满足
$$
a^x\equiv b(mod~p)\\
$$

### 思路：

 设$x=A\sqrt p-B$其中$A\in(0,\sqrt p],B\in[0,\sqrt p)$，得到问题的变形
$$
a^{A\sqrt p-B}\equiv b(mod~p)\\
a^{A\sqrt p}\equiv ba^B(mod~p)\\
$$
我们先枚举$B$，算出每个$ba^B~mod~p$，用$unordered\_map$存起来，再枚举$A$，计算出$a^{A\sqrt p}$，在$unordered\_map$中找相同的值，这样的$A,B$就能恰好凑成一对答案。复杂度$O(\sqrt p)$，如果用$map$的话，就多一个$log$。



### 模板：



#### [P2485 [SDOI2011]计算器](https://www.luogu.com.cn/problem/P2485)

#### [[TJOI2007] 可爱的质数/【模板】BSGS](https://www.luogu.com.cn/problem/P3846)



## 进阶篇

### 问题：

$$
x^a\equiv b(mod~p)\\
$$

### 解法一：

设$g$是p的一个原根，根据原根的性质存在$c$，满足$g^c\equiv x$成立，同理存在$t$，满足$g^t\equiv b$成立。
$$
\therefore (g^c)^a\equiv b(mod~p)\\
(g^a)^c\equiv b(mod~p)\\
g^a已知，所以我们就能用基础篇直接求解c，也就是一个特解。
$$


### 解法二：

设$g$是p的一个原根，根据原根的性质存在$c$，满足$g^c\equiv x$成立，同理存在$t$，满足$g^t\equiv b$成立。
$$
\therefore g^{ac}\equiv g^t(mod~p)\\
根据阶的性质有\\
\therefore ac\equiv t(mod~\varphi(p))\\
根据exgcd求出c，也是一个特解。
$$

### 求全部的解：

我们在已知一个特解$g^c$的情况下，我们要得到全部解。
$$
\because g^{\varphi(p)}\equiv1(mod~p)\\
\therefore\forall t\in\mathbb{Z}, x^a\equiv g^{ca+\frac {t\varphi(p)}a}(mod~p)\\
\therefore\forall t\in\mathbb{Z}且a|t\varphi(p),x\equiv g^{c+\frac{t\varphi(p)}{a}}(mod~p)\\
\because a|t\varphi(p)\\
\therefore \frac a{gcd(a, \varphi(p))}|t\\
\therefore t =\frac a{gcd(a, \varphi(p))}i\\
\therefore 全部的解为：\forall i\in\mathbb{Z},x\equiv g^{c+\frac {\varphi(p)}{gcd(a,\varphi(p))}i}(mod~p)\\
$$
​	



### 题目：

#### [P3306 [SDOI2013] 随机数生成器](https://www.luogu.com.cn/problem/P3306)





$$
x_{i+1}\equiv ax_i+b(mod~p)\\
x_{i+1}+\frac b{a-1}\equiv a(x_i+\frac b{a-1})(mod~p)\\
x_n\equiv t(mod~p)\\
a^{n-1}(x_1+\frac b{a-1})-\frac b{a-1}\equiv t(mod~p)\\
a^{n-1}\equiv (t + \frac b{a-1})*inv(x_1+\frac b{a-1})(mod~p)\\
$$


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll qpow(ll x, ll y, ll mod) {
    ll ans = 1;
    while(y) {
        if(y & 1) ans = ans * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return ans;
}

unordered_map<ll, ll> mp;
ll bsgs(ll a, ll b, ll p) {
    if(a % p == 0) return -1;
    mp.clear();
    ll k = ceil(sqrt(p));
    for(int i=0; i<=k; i++) {
        mp[b] = i;
        b = b * a % p;
    }
    ll aa = qpow(a, k, p), A = aa;
    for(int i=1; i<=k; i++) {
        if(mp[aa]) {
            return 1ll * i * k - mp[aa] + 1;
        }
        aa = aa * A % p;
    }
    return -1;
}
int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif
    int t;
    cin >> t;
    while(t--) {
        ll p, a, b, x, t;
        cin >> p >> a >> b >> x >> t;
        if(x == t) {
            cout << 1 << endl;
            continue;
        }
        if(a == 0) {
            if(b == t) cout << 2 << endl;
            else cout << -1 << endl;
            continue;
        }
        if(a == 1) {
            if(b == 0) cout << -1  << endl;
            else {
                ll k = qpow(b, p-2, p);
                cout << ((t-x+p)%p*k)  % p + 1 << endl;
            }
            continue;
        }

        ll tmp = b*qpow(a-1, p-2, p) % p;
        t = (t + tmp) % p;
        t = t * qpow((x+tmp)%p, p-2, p) % p;
        ll ans = bsgs(a, t, p);
        cout << ans << endl;
    }
    return 0;
}
```





#### [261. Discrete Roots模板](https://codeforces.com/problemsets/acmsguru/problem/99999/261)



```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll qpow(ll x, ll y, ll mod) {
	ll ans = 1;
	while(y) {
		if(y & 1) ans = ans * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return ans;
}
ll G(ll p) {
	if(p == 2) return 1;
	vector<ll> tmp;
	int phi = p-1, n = phi;
	for(int i=2; 1ll*i*i<=n; i++) {
		if(n % i == 0) {
			tmp.push_back(i);
			while(n % i == 0) n /= i;
		}
	}
	if(n > 1) tmp.push_back(n);
	for(int i=1; i<=p; i++) {
		bool flag = 0;
		for(auto it : tmp) {
			if(qpow(i, phi/it, p) == 1) {
				flag = 1;
				break;
			}
		}
		if(!flag) return i;
	}
	return -1;
}
unordered_map<ll, ll> mp;
ll bsgs(ll a, ll b, ll p) {
	if(a % p == 0 && b != 0) return -1;
	mp.clear();
	int k = ceil(sqrt(p));
	for(int i=0; i<=k; i++) {
		mp[b] = i;
		b = b * a % p;
	}
	ll aa = qpow(a, k, p), A = aa;
	for(int i=1; i<=k; i++) {
		if(mp[A]) return 1ll * i * k - mp[A];
		A = A * aa % p;
	}
	return -1;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif
	ll p, k, a;
	while(cin >> p >> k >> a) {
		if(a == 0) {
			cout << "1\n0\n";
			continue;
		}
		ll g = G(p), gk = qpow(g, k, p);
		ll x0 = bsgs(gk, a, p), t = bsgs(g, a, p);
		if(x0 == -1) {
			cout << "0\n";
			continue;
		}

		vector<ll> ans;
		ll d = __gcd(p-1, k), mod = (p-1)/d;
		x0 = x0 % mod;
		for(int i=0; i<d; i++) {//最多只有d个不同的解。
			ans.push_back(qpow(g, ( x0+i*mod%(p-1) )%(p-1), p));
		}
		sort(ans.begin(), ans.end());
		cout << ans.size() << endl;
		for(auto it : ans) cout << it << ' ';
		cout << endl;
	}
	return 0;
}
```

#### [F. Lunar New Year and a Recursive Sequence](https://codeforces.com/contest/1106/problem/F)

##### 题意：

给出$f_1=f_2=\cdots=f_{k-1}=1$和$b_1,b_2\cdots b_k$，还有递推方程
$$
f_i=f_{i-1}^{b_1}f_{i-2}^{b_2}\cdots f_{i-k}^{b_k}\\
$$


问是否存在一个$f_k$使得$f_n\equiv m(mod~p)$成立；

##### 思路：

矩阵快速幂$+BSGS$

因为$n$很大，所以不能直接推出$f_n$是$f_k$的多少次方，观察递推式全是乘法，我们就想到用矩阵加速。



先推出矩阵。

假设$k=4$，则可以推出下面的式子。
$$
\begin{aligned}\label{}
&f_k=f_k\\
&f_{k+1}=f_k^{b_1}f_{k-1}^{b_2}f_{k-2}^{b_3}f_{k-3}^{b_4}=f_k^{b_1}\\
&f_{k+2}=f_{k+1}^{b_1}f_k^{b_2}f_{k-1}^{b_3}f_{k-2}^{b_4}=(f_k^{b_1})^{b_1}f_k^{b_2}=f_k^{b_1^2+b_2}\\
&f_{k+3}=f_{k+2}^{b_1}f_{k+1}^{b_2}f_k^{b_3}f_{k-1}^{b_4}=f_k^{b_1^3+2b_1*b_2+b_3}\\
&f_{k+4}=f_{k+3}^{b_1}f_{k+2}^{b_2}f_{k+1}^{b_3}f_k^{b_4}=f_k^{b_1^4+3b_1^2b_2+2b_1b_3+b_2^2+b_4}\\
&f_{k+5}=f_{k+4}^{b_1}f_{k+3}^{b_2}f_{k+2}^{b_3}f_{k+1}^{b_1}\\
\end{aligned}
$$
我们可以看出每个$f_i$都是由前$k$个$f$值推出来的，所以我们设$f_i$的对应的$f_k$的系数是$g_i$

我们就能找到一个一维的矩阵乘法
$$
\left[
\begin{matrix}
g_4,g_3,g_2,g_1
\end{matrix}
\right]\times
\left[
\begin{matrix}
b_1\\b_2\\b_3\\b_4
\end{matrix}
\right]=g_5
$$

$$
\left[
\begin{matrix}
g_5,g_4,g_3,g_2
\end{matrix}
\right]\times
\left[
\begin{matrix}
b_1\\b_2\\b_3\\b_4
\end{matrix}
\right]=g_6
$$

所以我们把矩阵扩展到$k$维，希望得到一个包含$g_i$的矩阵乘以另一个矩阵得到包含形式相同且包含$g_{i+1}$的矩阵，

推出：
$$
\left[
\begin{matrix}
g_7&g_6&g_5&g_4
\\g_6&g_5&g_4&g_3
\\g_5&g_4&g_3&g_2
\\g_4&g_3&g_3&g_1
\end{matrix}
\right]\times
\left[
\begin{matrix}
b_1&1&0&0
\\b_2&0&1&0
\\b_3&0&0&1
\\b_4&0&0&0

\end{matrix}
\right]=
\left[
\begin{matrix}
g_8&g_7&g_6&g_5
\\g_7&g_6&g_5&g_4
\\g_6&g_5&g_4&g_3
\\g_5&g_4&g_3&g_2
\end{matrix}
\right]
$$

通过$k=4$的特例，我们能够推出$k$是范围内的任意矩阵。

我们就能推出$f_n$是$f_k$的多少次方，设$f_n$$=f_k^a$。

现在的问题是已知$a$，求是否存在$f_k$使$f_k^a\equiv m(mod~p)$成立。

这个就是之前的$bsgs$的进阶篇：[进阶篇](https://blog.csdn.net/weixin_45363113/article/details/116404529?spm=1001.2014.3001.5501)





#### $Code:$


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e2+10;
const int mod = 998244353;
vector<ll> a;
ll b[N], k;
struct matrix {
    ll s[N][N];
    matrix operator * (const matrix &t) {
        matrix tmp;
        for(int i=1; i<=k; i++) {
            for(int j=1; j<=k; j++) {
                tmp.s[i][j] = 0;
                for(int l=1; l<=k; l++) {
                    tmp.s[i][j] = (tmp.s[i][j] + s[i][l] * t.s[l][j] % (mod-1)) % (mod-1);
                }
            }
        }
        return tmp;
    }
} A, I, B;

matrix mqpow(matrix t, ll y) {
    matrix ans = I;
    while(y) {
        if(y & 1) ans = ans * t;
        t = t * t;
        y >>= 1;
    }
    return ans;
}

ll qpow(ll x, ll y) {
    ll ans = 1;
    while(y) {
        if(y & 1) ans = ans * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return  ans;
}

ll G(ll p) {
    vector<int> v;
    ll phi = p-1, tmp = phi;
    for(int i=2; 1ll*i*i<=tmp; i++) {
        if(tmp % i == 0) {
            v.push_back(i);
            while(tmp % i == 0) tmp /= i;
        }
    }
    if(tmp > 1) v.push_back(tmp);
    for(int i=2; i<=phi; i++) {
        int f = 1;
        for(auto it : v) {
            if(i % it == 0) {
                f = 0;
                break;
            }
            if(f) return i;
        }
    }
    return -1;
}
unordered_map<ll, ll> mp;
ll bsgs(ll aaa, ll b, ll p) {
    mp.clear();
    if(aaa % p == 0 && b % p != 0) return -1;
    int k = ceil(sqrt(p));
    for(int i=0; i<=k; i++) {
        mp[b] = i, b = b * aaa % mod;
    }
    ll aa = qpow(aaa, k), A = aa;
    // cout << aa<< endl;
    for(int i=1; i<=k; i++) {
        if(mp[A]) return 1ll*i*k - mp[A];
        A = A * aa % mod;
    }
    return -1;
}
int main() {    
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif
    scanf("%lld", &k);
    for(int i=1; i<=k; i++) I.s[i][i] = 1;
    for(int i=1; i<=k; i++) {
        scanf("%lld", &b[i]);
    }
    for(int i=1; i<k; i++) a.push_back(0);
    a.push_back(1); 
    for(int i=1; i<=k; i++) {
        ll tmp = 0;
        for(int j=1; j<=k; j++) {
            tmp = (tmp + b[j] * a[a.size()-j] % (mod-1)) % (mod-1);
        }
        a.push_back(tmp);
    }
    ll n, m, aa;
    scanf("%lld%lld", &n, &m);
    if(n <= 2*k) {
        aa = a[n-1] % (mod-1);
    }
    else {
        for(int j=1, i=a.size()-1; j<=k; j++, i--) {
            int l = 1;
            while(l <= k) {
                A.s[j][l] = a[i-l+1];
                // cout << i-l+1 << endl;
                l++;
            }
        }
        for(int i=1; i<=k; i++) {
            for(int j=1; j<=k; j++) {
                if(i == 1) B.s[j][i] = b[j];
                else if(j == i-1) {
                    B.s[j][i] = 1;
                }
            }
        }
        A = A * mqpow(B, n-2*k);
        aa = A.s[1][1]%(mod-1);
    }
    ll g = G(mod);
    ll ans = bsgs(qpow(g, aa), m, mod);
    if(ans != -1) cout << qpow(g, ans);
    else cout << -1 << endl;
    return 0;
}
```



## 扩展篇

### 问题：

当$p，a$可能不互质时，求
$$
a^x\equiv b(mod~p)\\
$$

## 方法:

当$d_1=gcd(a,p)\neq1$，当$d_1\nmid b$时，无解，则原式变成：
$$
\frac a{d_1}a^{x-1}\equiv \frac b{d_1}(mod~\frac p{d_1})\\
$$
当设$d_2=gcd(a,\frac p{d_1})\neq1$，当$d_2\nmid \frac b{d_1}$时，无解，则原式可变成：
$$
\frac {a^2}{d_1d_2}a^{x-2}\equiv \frac b{d_1d_2}(mod~\frac p{d_1d_2})\\
$$
重复直到$d_{cnt}=1$。设$D=\prod_{i=1}^{cnt}d_i$，原式可以写成：
$$
\frac {a^{cnt}}Da^{x-cnt}\equiv \frac bD(mod~\frac pD)\\
$$
剩下的$a^{x-cnt},\frac bD,\frac pD$，可以构成基础篇的$bsgs$，修改的地方就是乘了一个系数$\frac {a^{cnt}}D$。

注意：$cnt$可能大于x这个解，所以我们在做除法的时候就要判断是不是能够相等，相等直接输出当前的$cnt$。



### 题目：



#### [P4195 【模板】扩展BSGS](https://www.luogu.com.cn/problem/P4195#submit)



```cpp
#include<bits/stdc++.h>using namespace std;typedef long long ll;ll qpow(ll x, ll y, ll mod) {    ll ans = 1;    while(y) {        if(y & 1) ans = ans * x % mod;        x = x * x % mod;        y >>= 1;    }    return ans;}unordered_map<ll, ll> mp;ll bsgs(ll a, ll b, ll p, ll ad) {    if(a % p == 0 && b%p != 0) return -1;    mp.clear();    int k = ceil(sqrt(p));    for(int i=0; i<k; i++) {        mp[b] = i;        b = b * a % p;    }    ll aa = qpow(a, k, p), A = aa*ad % p;    for(int i=1; i<=k; i++) {        if(mp[A]) return 1ll*i*k - mp[A];        A = A * aa % p;    }    return -1;}ll exgcd(ll &x, ll &y, ll a, ll b) {    if(b == 0) {        x = 1, y = 0;        return a;    }    ll d = exgcd(x, y, b, a%b);    ll tmp = y;    y = x - a/b * y;    x = tmp;    return d;}ll inv(ll a, ll b) {    ll x, y;    ll d = exgcd(x, y, a, b);    return x;}ll exbsgs(ll a, ll b, ll p) {    a %= p, b %= p;    if(b == 1 || p == 1) return 0;    ll cnt = 0, d, tmp = 1;    while((d = __gcd(a, p)) ^ 1) {        if(b % d) return -1;        cnt++, b /= d, p /= d;        tmp = tmp * a/d % p;        if(tmp == b) return cnt;    }    ll ans = bsgs(a, b, p, tmp);    if(ans == -1) return -1;    else return ans + cnt;}int main() {#ifndef ONLINE_JUDGE    freopen("in.txt", "r", stdin);    freopen("out.txt", "w", stdout);#endif    ll a, p, b, d;    while(cin >> a >> p >> b) {        if(!a || !p || !b) break;        ll ans = exbsgs(a, b, p);        if(ans != -1) cout << ans << endl;        else cout << "No Solution\n";    }    return 0;}
```















# 阶和原根



## 阶

### 定义：

对于$m>1$且$(a,m)=1$，使$a^n\equiv 1(mod~m)$成立的最小的$n$，称为$n$模$m$的阶，记作$\delta_m(a)$。

根据欧拉定理，可以证明至少存在一个$n$使$a^n\equiv 1(mod~p)$成立。

### 性质：

1. $a,a^2,...,a^{\delta_m(a)}$在模$m$下互不同余。																																																																							

证明：

假设存在$i，j\in[1,\delta_m(a)])$，使$a^i\equiv a^j(mod ~m)$，则可以变形成$a^{|i-j|}\equiv 1(mod~m)$，易知$|i-j|<\delta_m(a)$，与阶的定义相矛盾，所以假设不成立，故原命题成立。



2. 若$a^n\equiv1(mod~m)$，则$\delta_m(a)|n$。

证明：

假设$\delta_m(a)\nmid n$，则$n=k\delta_m(a)+r（r>0）$，$a^{k\delta_m(a)}a^r\equiv a^r\equiv1(mod~m)$，根据性质1，可知假设不成立，原命题成立。

可以推出：$a^p\equiv a^q(mod~m)$，则$p\equiv q(mod~\delta_m(a))$。



3. 设$m>1$，$a，b\in\mathbb{Z}$，$(a,m)=(b,m)=1$，则$\delta_m(ab)=\delta_m(a)\delta_m(b)$的充要条件是：$(\delta_m(a),\delta_m(b))=1$

证明：

必要性：
$$
\because a^{\delta_m(a)}\equiv1(mod~p)和b^{\delta_m(b)}\equiv1(mod~m)\\
\therefore (ab)^{[\delta_m(a),\delta_m(b)]}\equiv1(mod~m)\\
\because 性质2\\
\therefore\delta_m(ab)\mid[\delta_m(a),\delta_m(b)]\\
\because\delta_m(a)\delta_m(b)|=\delta_m(ab)\\
\therefore \delta_m(a)\delta_m(b)|[\delta_m(a),\delta_m(b)]\\
\therefore(\delta_m(a),\delta_m(b))=1
$$
充分性：
$$
\because (ab)^{\delta_m(ab)}\equiv 1(mod~m)\\
\therefore (ab)^{\delta_m(ab)\delta_m(b)}\equiv a^{\delta_m(ab)}b^{\delta_m(b)}\equiv a^{\delta_m(ab)}\equiv1(mod~m)\\
\therefore \delta_m(a)\mid\delta_m(ab)\\
同理：\delta_m(b)\mid\delta_m(ab)\\
\therefore \delta_m(a)\delta_m(b)\mid\delta_m(ab)\\
\because a^{\delta_m(a)}b^{\delta_m(b)}\equiv (ab)^{\delta_m(a)\delta_m(b)}\\
\therefore \delta_m(ab)\mid\delta_m(a)\delta_m(b)\\

综上：\delta_m(ab)=\delta_m(a)\delta_m(b)\\
$$


4. 设$k\in\mathbb{N},m>1,a\in\mathbb{Z},(a,m)=1$，则：$\delta_m(a^k)=\frac {\delta_m(a)}{(\delta_m(a),k)}$.

证明：
$$
\because (a^k)^{\delta_m(a^k)}\equiv a^{k\delta_m(a^k)}\equiv1(mod~m)\\
\therefore \delta_m(a)\mid k\delta_m(a^k)\\
\therefore\frac {\delta_m(a)}{(\delta_m(a),k)}\mid\delta_m(a^k)\\
\because (a^k)^{\frac {\delta_m(a)}{(\delta_m(a),k)}}\equiv(a^{\delta_m(a)})^{\frac k{(\delta_m(a),k)}}\equiv1(mod~m)\\
\therefore\delta_m(a^k)\mid\frac {\delta_m(a)}{(\delta_m(a),k)}\\
综上：\delta_m(a^k)=\frac {\delta_m(a)}{(\delta_m(a),k)}\\
$$



## 原根

## 定义:

设$m\in\mathbb{N^*}$,$a\in\mathbb{Z}$.若$(a,m)=1$,且$\delta_m(a)=\phi(m)$,则称$a$为模$m$的原根（注：$a，m$互质）.



## 原根判定定理

若$g$是模$m$的一个原根,则对于$\phi(m)$的任何大于$1$且不为自身的素因数$p$,都有$g^{\frac{\phi(m)}p}\not\equiv1(mod~m)$.

证明:

假设存在一个$t<\phi(m)$使得$a^t\equiv1(mod~m)$且$\forall i\in[1,k]:a^{\frac {\phi(m)}{d_i}}\equiv1(mod~m)$.

由裴蜀定理得，一定存在一组$k，x$满足$kt=x\phi(m)+(t,\phi(m))$; 由欧拉定理$/$费马小定理得$a^{\phi(p)}\equiv1(mod~p)$;

$\therefore 1\equiv a^{kt}\equiv a^{x\phi(m)}a^{(t,\phi(m))}\equiv a^{(t,\phi(m))}(mod~m)$

$\because t<\phi(m)~\therefore(t,\phi(m))\le t<\phi(m)$

$\because (t,\phi(m))|\phi(m)，\therefore(t,\phi(m))一定至少整除\frac {\phi(m)}{d_i}中的至少一个$。	

设$(t,\phi(m))|\frac {\phi(m)}{d_i}$,则$a^{\frac {\phi(m)}{d_i}}\equiv a^{(t,\phi(m))}\equiv1(mod~m)$。

$\therefore$ 假设不成立，原命题成立







## 原根的个数

如果一个数$m$有原根$g$，则它的原根个数为$\phi(\phi(m))$。

证明：

如果$m$存在原根$g$，则
$$
\delta_m(g^k)=\frac {\delta_m(g)}{(\delta_m(g), k)}(阶的性质)\\
if~(k,\delta_m(g))=1且1<k<\phi(m)的k有\phi(\phi(m))个。\\
\therefore 原根有\phi(\phi(m))个。
$$
原根一定是$\phi(\phi(m))$个，在模$m$的情况下。



## 原根的存在定理

一个数m存在原根当且仅当$m=2，4，p^{\alpha}，2p^{\alpha}$，其中$p$为奇素数。$\alpha\in\mathbb{N^*}$。

1. 对于$m=2，4$，原根显然存在。

2. 对于$m=p^{\alpha}$，其中$p$为奇素数，$\alpha\in\mathbb{N^*}$。

   证明：

   首先我们先来证明：$对于奇素数p，p有原根。$

   先引入一个引理：

   > 设$a,b$是和$m$互质的两个整数，则存在$c\in\mathbb{Z}$使得$\delta_m(c)=lcm(\delta_m(a),\delta_m(b)))$
   > 证明：我们先对$\delta_m(a),\delta_m(b)$进行质因子分解，$k$是$\delta_m(a),\delta_m(b)$的素因子种类数。
   > $$
   > \delta_m(a)=\prod_{i=1}^kp_i^{\alpha_i}，\delta_m(b)=\prod_{i=1}^kp_i^{\beta_i}
   > $$
   > 然后就可以设成下面的形式
   > $$
   > \delta_m(a)=XY,\delta_m(b)=ZW\\
   > $$
   > 其中：$[x]$:表示当$x\ne0$时等于$1$，否则等于$0$
   > $$
   > Y=\prod_{i=1}^kp_i^{[\alpha_i>\beta_i]a_i}，X=\frac {\delta_m(a)}{Y}=\prod_{i=1}^kp^{[\alpha_i\le\beta_i]\alpha_i}\\ W=\prod_{i=1}^kp_i^{[\alpha_i\le\beta_i]\beta_i},Z=\frac {\delta_m(b)}{W}=\prod_{i=1}^kp^{[\alpha_i>\beta_i]\beta_i}\\
   > \therefore(X,Z)=1\\
   > \because (\delta_m(a),\delta_m(b))=\prod_{i=1}^kp_i^{min(\alpha_i,\beta_i)}=XW\\
   > \therefore lcm(\delta_m(a),\delta_m(b))=YZ
   > $$
   > 由阶的性质4，得：
   > $$
   > \delta_m(a^X)=\frac {\delta_m(a)}{(\delta_m(a), X)}=\frac {XY}X=Y\\
   > $$
   > 同理：
   > $$
   > \delta_m(b^Z)=W\\
   > $$
   >
   > 
   >
   > $$
   > \because (Y, W)=1,YZ=lcm(\delta_m(a), \delta_m(b))。\\
   > \therefore \delta_m(a^Xb^Z)=\delta_m(a^X)\delta_m(b^Z)=YZ\\
   > $$
   >
   > 

   







# 欧拉定理和扩展欧拉定理

欧拉定理：

$gcd(a,m)=1$

$a^{\phi(m)}\equiv1(mod~m)$





扩展欧拉定理：



$$
a^b\equiv\begin{cases}a^b~mod~ \phi(m)&gcd(m,a)=1\\
a^b&gcd(m,a)\ne1,b<\phi(m)\\
a^{(b~mod~\phi(m)+\phi(m))}&gcd(m,a)\ne1,b\ge\phi(m)
\end{cases}
~(mod~m)\\
$$


### [P4139 上帝与集合的正确用法](https://www.luogu.com.cn/problem/P4139)

可以更快

```cpp
#include <bits/stdc++.h>using namespace std;// #define double long doubletypedef long long ll;typedef unsigned long long ull;const int N = 1e7+10;const int mod = 1e9+7;const double esp = 1e-12;const ull base = 1331;int phi[N], p[N], tot;bool st[N];void init() {    phi[1] = 1;    for(int i=2; i<N; i++) {        if(!st[i]) phi[i] = i-1, p[tot++] = i;        for(int j=0; j<tot&&1ll*i*p[j]<N; j++) {            st[i*p[j]] = 1;            if(i % p[j] == 0) {                phi[i*p[j]] = phi[i]*p[j];                break;            }            phi[i*p[j]] = phi[i] * (p[j]-1);        }    }}ll qpow(ll x, ll y, ll p) {    ll ans = 1;    while(y) {        if(y & 1) {            ans = ans * x;            if(ans >= p) ans = ans % p + p;        }        x = x * x;        if(x >= mod) x = x % p + p;        y >>= 1;    }    return ans;}vector<int> v;ll s[N];int Phi(int x) {    int ans = x;    for(int i=0; i<tot&&p[i]*p[i]<=x; i++) {        if(x % p[i] == 0) {            ans = ans/p[i] * (p[i]-1);            while(x % p[i] == 0) x /= p[i];        }    }    if(x > 1) ans = ans / x * (x - 1);    return ans;} void Init(int p) {    while(p > 1) {        v.push_back(p);        if(p >= N) p = Phi(p);        else p = phi[p];    }}int main() {#ifndef ONLINE_JUDGE     freopen("in.txt", "r", stdin);    freopen("out.txt", "w", stdout);#endif     init();    int n, m;    cin >> n >> m;    Init(m);    v.push_back(1);    for(int i=1; i<=n; i++) {        cin >> s[i];    }    int t, l, r;    cin >> t;    while(t--) {        cin >> l >> r;        ll ans = 1;        int k = min((int)v.size(), r-l+1);        while(k) {            int id = l+k-1;            ans = qpow(s[id], ans, v[k-1]);            k--;        }        cout << ans % m << endl;    }}   
```











### 	P3934 [Ynoi2016] 炸脖龙 I





```CPP
#include <bits/stdc++.h>using namespace std;// #define double long doubletypedef long long ll;// typedef unsigned long long ull;const int N = 2e7+10;// const int mod = 1e9+7;const double esp = 1e-12;// const ull base = 1331;int p[N], phi[N], tot;bool st[N];void init() {    phi[1] = 1;    for(int i=2; i<N; i++) {        if(!st[i]) p[tot++] = i, phi[i] = i-1;        for(int j=0; j<tot&&1ll*i*p[j]<N; j++) {            st[i*p[j]] = 1;            if(i % p[j] == 0) {                phi[i*p[j]] = phi[i]*p[j];                break;            }            phi[i*p[j]] = phi[i] * (p[j]-1);        }    }}int n, m;ll tr[N];void add(ll x, ll y) {    while(x <= n) {        tr[x] += y;        x = x + (x & (-x));    }}ll query(ll x) {    ll ans = 0;    while(x) {        ans += tr[x];        x = x - (x & (-x));    }    return ans;}ll qpow(ll x, ll y, ll mod) {    ll ans = 1;    int f = 0;    if(x > mod) {        f = 1;         x %= mod;    }    while(y) {        if(y & 1) {            ans = ans * x;            if(ans >= mod) f = 1;            ans = ans % mod;        }        x = x * x;        if(x >= mod) f = 1;        x %= mod;        y >>= 1;    }    if(f) ans += mod;    return ans;}int s[N];ll dfs(ll a, ll b, ll c) {    if(c == 1) return 1;    ll tmp = query(a);    if(a == b) return tmp >= c ? tmp % c + c : tmp;    tmp = dfs(a+1, b, phi[c]);    return qpow(query(a), tmp, c);}int main() {#ifndef ONLINE_JUDGE     freopen("in.txt", "r", stdin);    freopen("out.txt", "w", stdout);#endif     init();    // for(int i=0; i<10; i++) cout << p[i] << endl;    scanf("%d%d", &n, &m);    for(int i=1; i<=n; i++) {        scanf("%d", &s[i]);        add(i, s[i]-s[i-1]);        // cout << query(i);    }    int f, l, r, p;    for(int i=1; i<=m; i++) {         scanf("%d%d%d%d", &f, &l, &r, &p);        if(f == 1) {            add(l, p);            if(r+1 <= n) add(r+1, -p);        }        else {            printf("%lld\n", dfs(l, r, p)%p);        }    }    }   
```











# 高斯消元

## 硬模拟

```cpp
#include<bits/stdc++.h>using namespace std;const int N = 2e2+10;const double eps = 1e-6;double s[N][N], ans[N];int n;bool gusses() {    int i = 1, j = 1;    while(i <= n && j <= n) {        int mx = fabs(s[i][j]), id = i;        for(int k=i+1; k<=n; k++) {            if(mx < fabs(s[k][j])) mx = fabs(s[k][j]), id = k;        }        if(fabs(mx) < eps) return false;        if(id != i)            for(int k=j; k<=n+1; k++) {                swap(s[i][k], s[id][k]);            }        for(int k=i+1; k<=n; k++) {            double tmp = s[k][j] / s[i][j];            s[k][j] = 0;            for(int l=j+1; l<=n+1; l++) {                s[k][l] -= s[i][l] * tmp;            }        }        i++, j++;    }    for(int k=n; k>=1; k--) {        double tmp = s[k][n+1];        for(int l=k+1; l<=n; l++) {            tmp -= s[k][l] * ans[l];        }        ans[k] = tmp / s[k][k];    }    return true;}int main() {#ifndef ONLINE_JUDGE    freopen("in.txt", "r", stdin);    freopen("out.txt", "w", stdout);#endif    cin >> n;    for(int i=1; i<=n; i++) {        for(int j=1; j<=n+1; j++) {            cin >> s[i][j];        }    }    if(gusses()) {        for(int i=1; i<=n; i++) {           printf("%.2lf\n", ans[i]);        }     }    else cout << "No Solution\n";    return 0;}
```



## 异或高斯消元



















# 线性基



en，线性基就是一组基底（类似向量）。



##  [WC2011 最大XOR和路径](https://www.luogu.com.cn/problem/P4151)



```cpp
#include<bits/stdc++.h>using namespace std;typedef long long ll;ll p[100];void insert(ll x) {    for(int i=51; i>=0; i--) {        if(!((x >> i) & 1)) continue;        if(!p[i]) {            p[i] = x;            break;        }        x ^= p[i];    }}int main() {#ifndef ONLINE_JUDGE    freopen("in.txt", "r", stdin);    freopen("out.txt", "w", stdout);#endif    int n;    ll x;    cin >> n;    for(int i=1; i<=n; i++) {        cin >> x;        insert(x);    }    ll ans = 0;    for(int i=51; i>=0; i--) {        if((ans ^ p[i]) > ans) ans = ans ^ p[i];    }    cout << ans << endl;    return 0;}
```







##  [WC2011\]最大XOR和路径](https://www.luogu.com.cn/problem/P4151)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5+10;
int head[N], to[N], Next[N], val[N], tot;

void add(int x, int y, int z) {
    val[tot] = z, Next[tot] = head[x], to[tot] = y, head[x] = tot++; 
}
int p[100];
void insert(int x) {
    for(int i=63; i>=0; i--) {
        if(!((x >> i) & 1)) continue;
        if(!p[i]) {
            p[i] = x;
            return ;
        }
        x ^= p[i];
    }
}
int dis[N], vis[N];
void dfs(int x, int v) {
    dis[x] = v, vis[x] = 1;
    for(int i=head[x]; i!=-1; i=Next[i]) {
        int u = to[i], s = val[i];
        if(!vis[u]) dfs(u, v^s);
        else insert(v ^ s ^ dis[u]);
    }
}
signed main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif
    memset(head, -1, sizeof head);
    int n, m, x, y, z;
    cin >> n >> m;
    for(int i=1; i<=m; i++) {
        cin >> x >> y >> z;
        add(x, y, z);
        add(y, x, z);
    }
    dfs(1, 0);
    int ans = dis[n];
    for(int i=63; i>=0; i--) {
        if((ans ^ p[i]) > ans) ans ^= p[i];
    }
    cout << ans << endl;
    return 0;
}
```







## [XOR](https://vjudge.net/problem/HDU-3949)

 

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long


int a[100];
void insert(int x) {
    for(int i=62; i>=0; i--) {
        if(!(x >> i & 1)) continue;
        if(!a[i]) {
            a[i] = x;
            break;
        }
        x ^= a[i];
    }
}
vector<int> v;  
signed main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif
    int t, tot = 0;
    scanf("%lld", &t);
    while(t--) {
        printf("Case #%lld:\n", ++tot);
        int n, x;
        scanf("%lld", &n);
        for(int i=1; i<=n; i++) {
            scanf("%lld", &x);
            insert(x);
        }
        for(int i=0; i<=62; i++) {
            if(!a[i]) continue;
            for(int j=i-1; j>=0; j--) {
                if(a[i] >> j & 1) a[i] ^= a[j];
            } 
        }
        for(int i=0; i<63; i++) {
            if(a[i]) v.push_back(a[i]);
        }
        int m;
        scanf("%lld", &m);
        while(m--) {
            scanf("%lld", &x);
            int ans = 0;
            if(v.size() != n) x--;
            if(x >= (1ll<<v.size())) puts("-1");
            else {
                for(int i=0; i<v.size(); i++) {
                    if(x % 2) ans ^= v[i];
                    x >>= 1;
                }
                printf("%lld\n", ans);
            }
        }
        memset(a, 0, sizeof a);
        v.clear();
    }
    return 0;
}
```









## [P4869 albus就是要第一个出场](https://www.luogu.com.cn/problem/P4869)

规律：每个数字出现的次数相同

先判断线性基上是否在当前位置存放1，再判断要找的数上是否有这个1.



```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int long long
const int mod = 10086;
const int N = 1e3+10;
int a[N], b[N];
void insert(int x) {
    for(int i=30; i>=0; i--) {
        if(!(x >> i & 1)) continue;
        if(!a[i]) {
            a[i] = x;
            break;
        }
        x ^= a[i];
    }
}
int qpow(int x, int y) {
    x %= mod;
    int ans = 1;
    while(y) {
        if(y & 1) ans = ans * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return ans;
}
signed main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif
    int n, x;
    cin >> n;
    for(int i=1; i<=n; i++) {
        cin >> x;
        insert(x);
    }
    int m, ans = 0, tmp = 1, tot = 0;
    cin >> m;
    for(int i=0; i<=30; i++) {
        if(a[i]) {
            if((m >> i & 1)) ans += tmp;
            tmp = tmp << 1;
            tot++;
        }
    }
    cout << (ans * qpow(2, n-tot) % mod + 1) % mod; 
    return 0;
}
```





## [P3857 [TJOI2008]彩灯](https://www.luogu.com.cn/problem/P3857)



```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int long long
const int mod = 2008;
const int N = 1e3+10;
int a[N], tot;
string s;
void insert(int x) {
    for(int i=50; i>=0; i--) {
        if(!(x >> i & 1)) continue;
        if(!a[i]) {
            a[i] = x;
            tot++;
            break;
        }
        x ^= a[i];
    }
}
signed main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif
    int n, m;
    cin >> n >> m;
    for(int i=1; i<=m; i++) {
        cin >> s;
        int x = 0;
        reverse(s.begin(), s.end());
        for(int j=0; j<n; j++) {
            if(s[j] == 'O') x ^= (1ll << j);
        }
        insert(x);
    }
    cout << ((1ll << tot) ) % mod;
    return 0;
}
```





## [P4570 [BJWC2011]元素](https://www.luogu.com.cn/problem/P4570)



```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int long long
const int mod = 2008;
const int N = 1e3+10;
int a[N], tot;
bool insert(int x) {
    for(int i=60; i>=0; i--) {
        if(!(x >> i & 1)) continue;
        if(!a[i]) {
            a[i] = x;
            tot++;
            return true;
        }
        x ^= a[i];
    }
    return false;
}
struct Y {
    int x, y;
} b[N];
bool cmp(Y u, Y v) {
    return u.y > v.y;
}
signed main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif
    int n, x, y;
    cin >> n;
    for(int i=1; i<=n; i++) {
        cin >> x >> y;
        b[i] = {x, y};
    }
    int ans = 0;
    sort(b+1, b+1+n, cmp);
    for(int i=1; i<=n; i++) {
        if(insert(b[i].x)) ans += b[i].y;
    }
    cout << ans << endl;
    return 0;
}
```





## [P4301 [CQOI2013] 新Nim游戏](https://www.luogu.com.cn/problem/P4301)





```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int long long
const int mod = 2008;
const int N = 1e3+10;
int b[N], a[N];
bool insert(int x) {
    for(int i=30; i>=0; i--) {
        if(!(x >> i & 1)) continue;
        if(!a[i]) {
            a[i] = x;
            return true;
        }
        x ^= a[i];
    }
    return false;
}
signed main() {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);  
    freopen("out.txt", "w", stdout);
#endif
    int n;
    cin >> n;
    for(int i=1; i<=n; i++) {
        cin >> b[i];
    }
    int ans = 0;
    sort(b+1, b+1+n, greater<int>());
    for(int i=1; i<=n; i++) {
        if(!insert(b[i])) ans += b[i];
    }
    cout << ans;
    return 0;
}
```







